# GitLab CI in conjunction with GitLab Runner can use Docker Engine to test and build any application.
# Docker, when used with GitLab CI, runs each job in a separate and isolated container using the predefined image that is set up in .gitlab-ci.yml.
image: nexus.engageska-portugal.pt/ska-docker/tango-builder:latest

services:
- docker:dind

# During the development of software, there can be many stages until it's ready for public consumption.
# You sure want to first test your code and then deploy it in a testing or staging environment before you release it to the public.
# That way you can prevent bugs not only in your software, but in the deployment process as well.
# See also https://docs.gitlab.com/ee/ci/environments.html
stages:
- build_0
- build_1
- build_2
- build_3
- build_4
- build_5
- test
- push

# https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#authenticating-to-the-container-registry
before_script:
  - docker login -u $DOCKER_REGISTRY_USERNAME -p $DOCKER_REGISTRY_PASSWORD $DOCKER_REGISTRY_HOST

test-chart:
  stage: test
  tags:
  - docker-executor
  image: nexus.engageska-portugal.pt/ska-docker/deploy:0.4.0
  script:
  # install kubectl
  - curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.18.2/bin/linux/amd64/kubectl
  - chmod +x ./kubectl
  - sudo mv ./kubectl /usr/local/bin/kubectl
  # install helm
  - curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
  - chmod 700 get_helm.sh
  - ./get_helm.sh
  - cd charts/
  - export KUBE_NAMESPACE="ci-ska-docker-$CI_COMMIT_SHORT_SHA"
  - make k8s
  - make install-chart
  - make wait
  - make test
  after_script:
  - export KUBE_NAMESPACE="ci-ska-docker-$CI_COMMIT_SHORT_SHA"
  - cd charts/
  - make uninstall-chart
  - make delete_namespace
  environment:
    name: test
  artifacts:
    name: "$CI_PROJECT_NAME-$CI_JOB_ID"
    paths:
      - "charts/build/"
    reports:
      junit: charts/build/report.xml

